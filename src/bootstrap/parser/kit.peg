# Kit language PEG grammar
#
# https://github.com/arithy/packcc#syntax

%source {
#include <inttypes.h>

#include "../document.h"
#include "tokens.h"

float parseFloat(char* str) {
  char* end;
  return strtof(str, &end);
}

int parseInt(char* str, int base) {
  char* end;
  return strtoimax(str, end, base);
}

MaybeOf(NumSpec) parseNumSuffix(char* suffix) {
  if (strcmp(suffix, "c") == 0) return just(NumSpec, CChar);
  else if (strcmp(suffix, "i") == 0) return just(NumSpec, CInt);
  else if (strcmp(suffix, "s") == 0) return just(NumSpec, CSize);
  else if (strcmp(suffix, "u8") == 0) return just(NumSpec, Uint8);
  else if (strcmp(suffix, "u16") == 0) return just(NumSpec, Uint16);
  else if (strcmp(suffix, "u32") == 0) return just(NumSpec, Uint32);
  else if (strcmp(suffix, "u64") == 0) return just(NumSpec, Uint64);
  else if (strcmp(suffix, "i8") == 0) return just(NumSpec, Int8);
  else if (strcmp(suffix, "i16") == 0) return just(NumSpec, Int16);
  else if (strcmp(suffix, "i32") == 0) return just(NumSpec, Int32);
  else if (strcmp(suffix, "i64") == 0) return just(NumSpec, Int64);
  else if (strcmp(suffix, "f32") == 0) return just(NumSpec, Float32);
  else if (strcmp(suffix, "f64") == 0) return just(NumSpec, Float64);
  else return nothing(NumSpec);
}
}

# Type of user-defined auxiliary data accessible in code blocks
%auxil "Document*"

# Tokens

# syntactic elements
metaOpen              <- "#["   { (Token) { MetaOpen, posToSpan(auxil, $0s, $0e) } }
parenOpen             <- "("    { (Token) { ParenOpen, posToSpan(auxil, $0s, $0e) } }
parenClose            <- ")"    { (Token) { ParenClose, posToSpan(auxil, $0s, $0e) } }
curlyBraceOpen        <- "{"    { (Token) { CurlyBraceOpen, posToSpan(auxil, $0s, $0e) } }
curlyBraceClose       <- "}"    { (Token) { CurlyBraceClose, posToSpan(auxil, $0s, $0e) } }
squareBraceOpen       <- "["    { (Token) { SquareBraceOpen, posToSpan(auxil, $0s, $0e) } }
squareBraceClose      <- "]"    { (Token) { SquareBraceClose, posToSpan(auxil, $0s, $0e) } }
comma                 <- ","    { (Token) { Comma, posToSpan(auxil, $0s, $0e) } }
colon                 <- ":"    { (Token) { Colon, posToSpan(auxil, $0s, $0e) } }
semicolon             <- ";"    { (Token) { Semicolon, posToSpan(auxil, $0s, $0e) } }
tripleDot             <- "..."  { (Token) { TripleDot, posToSpan(auxil, $0s, $0e) } }
dot                   <- "."    { (Token) { Dot, posToSpan(auxil, $0s, $0e) } }
hash                  <- "#"    { (Token) { Hash, posToSpan(auxil, $0s, $0e) } }
dollar                <- "$"    { (Token) { Dollar, posToSpan(auxil, $0s, $0e) } }
arrow                 <- "=>"   { (Token) { Arrow, posToSpan(auxil, $0s, $0e) } }
functionArrow         <- "->"   { (Token) { FunctionArrow, posToSpan(auxil, $0s, $0e) } }
question              <- "?"    { (Token) { Question, posToSpan(auxil, $0s, $0e) } }
wildcardSuffix        <- ".*"   { (Token) { WildcardSuffix, posToSpan(auxil, $0s, $0e) } }
doubleWildcardSuffix  <- ".**"  { (Token) { DoubleWildcardSuffix, posToSpan(auxil, $0s, $0e) } }

# comments
comment               <- "//" [^\n]*
multiLineComment      <- "/*" (!'*' / '*' !'/' / '*\n' / '\n')* "*/"
comments              <- comment / multiLineComment

# keywords
abstract    <- 'abstract'   { (Token) { KeywordAbstract, posToSpan(auxil, $0s, $0e) } }
as          <- 'as'         { (Token) { KeywordAs, posToSpan(auxil, $0s, $0e) } }
break       <- 'break'      { (Token) { KeywordBreak, posToSpan(auxil, $0s, $0e) } }
const       <- 'const'      { (Token) { KeywordConst, posToSpan(auxil, $0s, $0e) } }
continue    <- 'continue'   { (Token) { KeywordContinue, posToSpan(auxil, $0s, $0e) } }
default     <- 'default'    { (Token) { KeywordDefault, posToSpan(auxil, $0s, $0e) } }
defer       <- 'defer'      { (Token) { KeywordDefer, posToSpan(auxil, $0s, $0e) } }
defined     <- 'defined'    { (Token) { KeywordDefined, posToSpan(auxil, $0s, $0e) } }
do          <- 'do'         { (Token) { KeywordDo, posToSpan(auxil, $0s, $0e) } }
else        <- 'else'       { (Token) { KeywordElse, posToSpan(auxil, $0s, $0e) } }
empty       <- 'empty'      { (Token) { KeywordEmpty, posToSpan(auxil, $0s, $0e) } }
enum        <- 'enum'       { (Token) { KeywordEnum, posToSpan(auxil, $0s, $0e) } }
extend      <- 'extend'     { (Token) { KeywordExtend, posToSpan(auxil, $0s, $0e) } }
for         <- 'for'        { (Token) { KeywordFor, posToSpan(auxil, $0s, $0e) } }
function    <- 'function'   { (Token) { KeywordFunction, posToSpan(auxil, $0s, $0e) } }
if          <- 'if'         { (Token) { KeywordIf, posToSpan(auxil, $0s, $0e) } }
implement   <- 'implement'  { (Token) { KeywordImplement, posToSpan(auxil, $0s, $0e) } }
implicit    <- 'implicit'   { (Token) { KeywordImplicit, posToSpan(auxil, $0s, $0e) } }
import      <- 'import'     { (Token) { KeywordImport, posToSpan(auxil, $0s, $0e) } }
include     <- 'include'    { (Token) { KeywordInclude, posToSpan(auxil, $0s, $0e) } }
inline      <- 'inline'     { (Token) { KeywordInline, posToSpan(auxil, $0s, $0e) } }
in          <- 'in'         { (Token) { KeywordIn, posToSpan(auxil, $0s, $0e) } }
macro       <- 'macro'      { (Token) { KeywordMacro, posToSpan(auxil, $0s, $0e) } }
match       <- 'match'      { (Token) { KeywordMatch, posToSpan(auxil, $0s, $0e) } }
null        <- 'null'       { (Token) { KeywordNull, posToSpan(auxil, $0s, $0e) } }
private     <- 'private'    { (Token) { KeywordPrivate, posToSpan(auxil, $0s, $0e) } }
public      <- 'public'     { (Token) { KeywordPublic, posToSpan(auxil, $0s, $0e) } }
return      <- 'return'     { (Token) { KeywordReturn, posToSpan(auxil, $0s, $0e) } }
rule        <- 'rule'       { (Token) { KeywordRule, posToSpan(auxil, $0s, $0e) } }
rules       <- 'rules'      { (Token) { KeywordRules, posToSpan(auxil, $0s, $0e) } }
Self        <- 'Self'       { (Token) { KeywordSelf, posToSpan(auxil, $0s, $0e) } }
sizeof      <- 'sizeof'     { (Token) { KeywordSizeof, posToSpan(auxil, $0s, $0e) } }
specialize  <- 'specialize' / 'specialise'  { (Token) { KeywordSpecialize, posToSpan(auxil, $0s, $0e) } } # common typo in the UK
static      <- 'static'     { (Token) { KeywordStatic, posToSpan(auxil, $0s, $0e) } }
struct      <- 'struct'     { (Token) { KeywordStruct, posToSpan(auxil, $0s, $0e) } }
then        <- 'then'       { (Token) { KeywordThen, posToSpan(auxil, $0s, $0e) } }
this        <- 'this'       { (Token) { KeywordThis, posToSpan(auxil, $0s, $0e) } }
throw       <- 'throw'      { (Token) { KeywordThrow, posToSpan(auxil, $0s, $0e) } }
tokens      <- 'tokens'     { (Token) { KeywordTokens, posToSpan(auxil, $0s, $0e) } }
trait       <- 'trait'      { (Token) { KeywordTrait, posToSpan(auxil, $0s, $0e) } }
typedef     <- 'typedef'    { (Token) { KeywordTypedef, posToSpan(auxil, $0s, $0e) } }
undefined   <- 'undefined'  { (Token) { KeywordUndefined, posToSpan(auxil, $0s, $0e) } }
union       <- 'union'      { (Token) { KeywordUnion, posToSpan(auxil, $0s, $0e) } }
unsafe      <- 'unsafe'     { (Token) { KeywordUnsafe, posToSpan(auxil, $0s, $0e) } }
using       <- 'using'      { (Token) { KeywordUsing, posToSpan(auxil, $0s, $0e) } }
var         <- 'var'        { (Token) { KeywordVar, posToSpan(auxil, $0s, $0e) } }
while       <- 'while'      { (Token) { KeywordWhile, posToSpan(auxil, $0s, $0e) } }
yield       <- 'yield'      { (Token) { KeywordYield, posToSpan(auxil, $0s, $0e) } }

# literals
"true" { (Token) { LiteralBool, posToSpan(auxil, $0s, $0e), (LiteralBoolData) { true } } }
"false" { (Token) { LiteralBool, posToSpan(auxil, $0s, $0e), (LiteralBoolData) { false } } }
'"' <('\\' . / !'"\\')*> '"' { (Token) { LiteralString, posToSpan(auxil, $0s, $0e), (LiteralStringData) { toString("$1") } } }
"'" <('\\' . / !"'\\")*> "'" { (Token) { LiteralString, posToSpan(auxil, $0s, $0e), (LiteralStringData) { toString("$1") } } }
'"""' <(!'"' / '"' !'"' / '""' !'"' / '\n')*> '"""' { (Token) { LiteralString, posToSpan(auxil, $0s, $0e), (LiteralStringData) { toString("$1") } } }
"c'" <'\\' . / !"\\'"> "'" { (Token) { LiteralChar, posToSpan(auxil, $0s, $0e), (LiteralCharData) { '$1' } } }

< '-'? [0-9]+ "." [0-9]* > "_" < 'f' ('32' / '64') > { (Token) { LiteralFloat, posToSpan(auxil, $0s, $0e), (LiteralFloatData) { parseFloat("$1"), parseNumSuffix("$2") } } }
numberSuffix <- [ui] ('8' / '16' / '32' / '64') / 'f' ('32' / '64') / [cis]
< "0x" [0-9a-fA-F]+ > "_" < numberSuffix > { (Token) { LiteralInt, posToSpan(auxil, $0s, $0e), (LiteralIntData) { parseInt("$1", 16), parseNumSuffix("$2") } } }
"0o" < [0-7]+ > "_" < numberSuffix > { (Token) { LiteralInt, posToSpan(auxil, $0s, $0e), (LiteralIntData) { parseInt("$1", 8), parseNumSuffix("$2") } } }
"0b" < [01]+ > "_" < numberSuffix > { (Token) { LiteralInt, posToSpan(auxil, $0s, $0e), (LiteralIntData) { parseInt("$1", 2), parseNumSuffix("$2") } } }
< '-'? ('0' / [1-9][0-9]*) > "_" < numberSuffix > { (Token) { LiteralInt, posToSpan(auxil, $0s, $0e), (LiteralIntData) { parseInt("$1", 10), parseNumSuffix("$2") } } }

'-'? [0-9]+ "." [0-9]* { (Token) { LiteralFloat, posToSpan(auxil, $0s, $0e), (LiteralFloatData) { parseFloat("$0"), nothing(NumSpec) } } }
"0x" [0-9a-fA-F]+ { (Token) { LiteralInt, posToSpan(auxil, $0s, $0e), (LiteralIntData) { parseInt("$0", 16), nothing(NumSpec) } } }
"0o" < [0-7]+ > { (Token) { LiteralInt, posToSpan(auxil, $0s, $0e), (LiteralIntData) { parseInt("$1", 8), nothing(NumSpec) } } }
"0b" < [01]+ > { (Token) { LiteralInt, posToSpan(auxil, $0s, $0e), (LiteralIntData) { parseInt("$1", 2), nothing(NumSpec) } } }
'-'? ('0' / [1-9][0-9]*) { (Token) { LiteralInt, posToSpan(auxil, $0s, $0e), (LiteralIntData) { parseInt("$0", 10), nothing(NumSpec) } } }

# operators
"+=" { (Token) { AssignOp, posToSpan(auxil, $0s, $0e), (AssignOpData) { Add } } }
"-=" { (Token) { AssignOp, posToSpan(auxil, $0s, $0e), (AssignOpData) { Sub } } }
"/=" { (Token) { AssignOp, posToSpan(auxil, $0s, $0e), (AssignOpData) { Div } } }
"*=" { (Token) { AssignOp, posToSpan(auxil, $0s, $0e), (AssignOpData) { Mul } } }
"%=" { (Token) { AssignOp, posToSpan(auxil, $0s, $0e), (AssignOpData) { Mod } } }
"&&=" { (Token) { AssignOp, posToSpan(auxil, $0s, $0e), (AssignOpData) { And } } }
"||=" { (Token) { AssignOp, posToSpan(auxil, $0s, $0e), (AssignOpData) { Or } } }
"&=" { (Token) { AssignOp, posToSpan(auxil, $0s, $0e), (AssignOpData) { BitAnd } } }
"|=" { (Token) { AssignOp, posToSpan(auxil, $0s, $0e), (AssignOpData) { BitOr } } }
"^=" { (Token) { AssignOp, posToSpan(auxil, $0s, $0e), (AssignOpData) { BitXor } } }
"<<=" { (Token) { AssignOp, posToSpan(auxil, $0s, $0e), (AssignOpData) { LeftShift } } }
">>=" { (Token) { AssignOp, posToSpan(auxil, $0s, $0e), (AssignOpData) { RightShift } } }
"=" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { Assign } } }
"++" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { Inc } } }
"--" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { Dec } } }
"+" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { Add } } }
"-" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { Sub } } }
"/" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { Div } } }
"*" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { Mul } } }
"%" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { Mod } } }
"==" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { Eq } } }
"!=" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { Neq } } }
">=" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { Gte } } }
"<=" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { Lte } } }
"<<" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { LeftShift } } }
">>" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { RightShift } } }
">" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { Gt } } }
"<" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { Lt } } }
"&&" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { And } } }
"||" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { Or } } }
"&" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { BitAnd } } }
"|" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { BitOr } } }
"^" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { BitXor } } }
"!" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { Invert } } }
"~" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { InvertBits } } }
"::" { (Token) { Op, posToSpan(auxil, $0s, $0e), (OpData) { Cons } } }
('*' / '/' / '+' / '-' / '^' / '=' / '<' / '>' / '!' / '&' / '%' / '~' / '@' / '?' / ':' / '.')+ { (Token) { CustomOp, (CustomOpData) { toString("$0") } } }

# identifiers
[_]*[a-z][a-zA-Z0-9_]* "!" { (Token) (\s -> Lex $ l2s $ B.take (B.length s - 1) s) }
[_]*[a-z][a-zA-Z0-9_]* { (Token) { LowerIdentifier, posToSpan(auxil, $0s, $0e), (LowerIdentifierData) { toString("$0") } } }
'@' <[a-z][a-zA-Z0-9_]*> { (Token) { LowerIdentifier, posToSpan(auxil, $0s, $0e), (LowerIdentifierData) { toString("$1") } } }
"`" [^`]+ "`" { (Token) (\s -> LowerIdentifier $ l2s $ B.take (B.length s - 2) $ B.drop 1 s) }
[_]*[A-Z][a-zA-Z0-9_]* { (Token) { UpperIdentifier, posToSpan(auxil, $0s, $0e), (UpperIdentifierData) { toString("$0") } } }
"``" <(!'`' / '`' !'`')+> "``" { (Token) { UpperIdentifier, posToSpan(auxil, $0s, $0e), (UpperIdentifierData) { toString("$1") } } }
"$" <[A-Za-z_][a-zA-Z0-9_]*> { (Token) { UpperIdentifier, posToSpan(auxil, $0s, $0e), (UpperIdentifierData) { toString("$1") } } }
"${" <[A-Za-z_][a-zA-Z0-9_]*> "}" { (Token) { MacroIdentifier, posToSpan(auxil, $0s, $0e), (MacroIdentifierData) { toString("$1") } } }
"```" <(!'`' / '`' !'`' / '``' !'`' / '\n')*> "```" { (Token) { InlineC, posToSpan(auxil, $0s, $0e), (InlineCData) { toString("$1") } } }

"_" _+ { (Token) { LowerIdentifier, posToSpan(auxil, $0s, $0e), (LowerIdentifierData) { toString("$0") } } }
"_" { (Token) { Underscore, posToSpan(auxil, $0s, $0e) } }

# Whitespace
_           <- whitespace*
whitespace  <- ' ' / '\t' / EOL
EOL         <- '\n' / '\r\n' / '\r'

# Grammar

Statements
  <- {[]} (
    Statements Statement / Statement / comments
    / Statements TypeDefinition DefinitionBody
    / Statements TraitDefinition DefinitionBody
    / Statements TraitImplementation DefinitionBody
  )

Statement
  <- import ModulePath ';'
  / import ModulePath wildcardSuffix ';'
  / import ModulePath doubleWildcardSuffix ';'
  / include str "=>" str ';'
  / include str ';'
  / using UsingClause ';'
  / MetaMods typedef upper_identifier '=' TypeSpec ';'
  / MetaMods default TypeSpec as TypeSpec ';'
  / rules upper_identifier '{' ShortRules '}'
  / VarDefinition {ps (varPos $1) $ VarDeclaration $ $1}
  / FunctionDefinition {ps (functionPos $1) $ FunctionDeclaration $1}
  / extend TypePath '{' DefStatements '}'
  / macro FunctionDefinitionBase
  / TypePath '(' CallArgs ')' ';'

TypeDefinition
  <- MetaMods enum upper_identifier TypeParams
  / MetaMods struct upper_identifier TypeParams
  / MetaMods union upper_identifier TypeParams
  / MetaMods abstract upper_identifier TypeParams TypeAnnotation

TraitDefinition
  <- MetaMods trait upper_identifier TypeParams AssocTypeDeclarations {
    newTraitDefinition {
      traitName = ns $ extract_upper_identifier $3,
      traitMeta = reverse $ metas $1,
      traitModifiers = reverse $ mods $1,
      traitParams = fst $4,
      traitAssocParams = reverse $5,
      traitPos = snd $2 <+> snd $3
    }
  }

TraitImplementation
  <- implement TypeParams TypeSpec AssocTypes for TypeSpec {
    newTraitImplementation {
      implTrait = fst $3,
      implFor = fst $6,
      implParams = fst $2,
      implAssocTypes = reverse $4,
      implPos = snd $1 <+> snd $3
    }
  }

AssocTypes <- '(' CommaDelimitedTypes ')'
AssocTypeDeclarations <- '(' TypeParams ')'

TopLevelExpr
  <- StandaloneExpr {$1}
  / ConstOrVar Identifier TypeAnnotation OptionalStandaloneDefault {pe (snd $1 <+> snd $4) $ LocalVarDeclaration (fst $2) (fst $3) (fst $1) (fst $4)}
  / return TopLevelExpr {pe (snd $1 <+> pos $2) $ Return $ Just $2}
  / return ';' {pe (snd $1) $ Return $ Nothing}
  # / defer TopLevelExpr {pe (snd $1 <+> pos $2) $ Defer $ $2}
  / continue ';' {pe (snd $1) $ Continue}
  / break ';' {pe (snd $1) $ Break}
  / yield Expr ';' {pe (snd $1 <+> pos $2) $ Yield $2}
  / tokens <str> {pe (snd $1 <+> snd $2) $ Tokens $ extract_lit $ fst $2}

StandaloneExpr
  <- ExprBlock {$1}
  / using UsingClauses StandaloneExpr {pe (snd $1 <+> snd $2) $ Using (reverse $ fst $2) $3}
  / IfStatement {$1}
  / static IfStatement {pe (snd $1 <+> pos $2) $ StaticExpr $2}
  / for Identifier in Expr ExprBlock {pe (snd $1 <+> pos $5) $ For (pe (snd $2) (Identifier (fst $2))) $4 $5}
  / while Expr ExprBlock {pe (snd $1 <+> pos $3) $ While $2 $3 False}
  / do ExprBlock while Expr ';' {pe (snd $1 <+> pos $4) $ While $4 $2 True}
  / match Expr '{' MatchCases DefaultMatchCase '}' {pe (snd $1 <+> snd $6) $ Match $2 (reverse $4) $5}
  / Expr ';' {me (pos $1) $1}

IfStatement
  <- if BinopTermOr ExprBlock {pe (snd $1 <+> pos $3) $ If $2 $3 (Nothing)}
  / if BinopTermOr ExprBlock else StandaloneExpr {pe (snd $1 <+> pos $5) $ If $2 $3 (Just $5)}

UsingClauses
  <- UsingClause {([fst $1], snd $1)}
  / UsingClauses ',' UsingClause {(fst $3 : fst $1, snd $1 <+> snd $3)}

UsingClause
  <- rules TypePath {(UsingRuleSet $ TypeSpec (fst $2) [] (snd $2), snd $1 <+> snd $2)}
  / implicit Expr {(UsingImplicit $ $2, snd $1 <+> pos $2)}

FunctionDefinition
  <- MetaMods function FunctionDefinitionBase {
    $3 {
      functionMeta = reverse $ metas $1,
      functionModifiers = reverse $ mods $1,
      functionPos = functionPos $3 <+> snd $2
    }
  }

FunctionDefinitionBase
  <- identifier TypeParams '(' VarArgs ')' TypeAnnotation OptionalBody {
    newFunctionDefinition {
      functionName = ns $ extract_identifier $1,
      functionParams = fst $2,
      functionType = fst $6,
      functionArgs = reverse (fst $4),
      functionBody = fst $7,
      functionVararg = snd $4,
      functionPos = snd $1
    }
  }

MatchCases
  <- {[]} (
    MatchCases MatchCase {$2 : $1}
    / MatchCase
  )

MatchCase
  <- Expr "=>" TopLevelExpr {MatchCase {matchPattern = $1, matchBody = $3}}

DefaultMatchCase
  <- default "=>" TopLevelExpr {Just $3}
  / {nothing(MatchCase)}

ExprBlock
  <- '{' MacroIdentifier '}' {pe (snd $1 <+> snd $3) $ Identifier (fst $2)}
  / '{' TopLevelExprs '}' {pe (snd $1 <+> snd $3) $ Block $ reverse $2}

TopLevelExprs
  <- {[]} (
    TopLevelExprs TopLevelExpr {$2 : $1} / TopLevelExpr
  )

ModulePath
  <- identifier {([extract_identifier $1], snd $1)}
  / ModulePath '.' identifier {(extract_identifier $3 : fst $1, snd $1 <+> snd $3)}

CallArgs
  <- {[]} (
    Expr {[$1]}
    / CallArgs ',' Expr {$3 : $1}
  )

MetaArg
  <- Term {MetaLiteral $ fst $ fst $1}
  / UpperOrLowerIdentifier {MetaIdentifier $ fst $1}

MetaArgs
  <- MetaArg {[$1]}
  / MetaArgs ',' MetaArg {$3 : $1}

Metadata
  <- "#[" identifier '(' MetaArgs ')' ']' {(Metadata {metaName = extract_identifier $2, metaArgs = reverse $4}, (snd $1) <+> (snd $6))}
  / "#[" identifier ']' {(Metadata {metaName = extract_identifier $2, metaArgs = []}, (snd $1) <+> (snd $3))}
  / "#[" ReservedIdentifier ']' {(Metadata {metaName = $2, metaArgs = []}, (snd $1) <+> (snd $3))}

ReservedIdentifier
  <- static {"static"}

MetaMods
  <- {(([], []), NoPos)}
  / MetaMods Metadata {let (meta, mods) = fst $1 in (((fst $2 : meta, mods)), snd $1 <+> snd $2)}
  / MetaMods public {let (meta, mods) = fst $1 in (((meta, Public : mods)), snd $1 <+> snd $2)}
  / MetaMods private {let (meta, mods) = fst $1 in (((meta, Private : mods)), snd $1 <+> snd $2)}
  / MetaMods inline {let (meta, mods) = fst $1 in (((meta, Inline : mods)), snd $1 <+> snd $2)}
  / MetaMods static {let (meta, mods) = fst $1 in (((meta, Static : mods)), snd $1 <+> snd $2)}

TypeAnnotation
  <- {(InferredType NoPos, NoPos)}
  / ':' TypeSpec {(fst $2, snd $1 <+> snd $2)}

TypeSpec
  <- TypePath TypeSpecParams {(if (fst $1) == ([], "Ptr") && length (fst $2) == 1 then PointerTypeSpec (head $ fst $2) (snd $1 <+> snd $2) else TypeSpec (fst $1) (fst $2) (snd $1 <+> snd $2), snd $1 <+> snd $2)}
  / '&' TypeSpec {(PointerTypeSpec (fst $2) (snd $1 <+> snd $2), snd $1 <+> snd $2)}
  / function FunctionTypeSpec {(fst $2, snd $2)}
  / '(' TypeSpec ',' CommaDelimitedTypes ')' {let p = snd $1 <+> snd $5 in (TupleTypeSpec ((fst $2) : (reverse $4)) p, p)}
  / Term {(ConstantTypeSpec (fst $ fst $1) (snd $1), snd $1)}
  / Self {(TypeSpec ([], B.pack "Self") [] (snd $1), snd $1)}
  / '_' {(InferredType $ snd $1, snd $1)}

FunctionTypeSpec
  <- '(' ')' "->" TypeSpec {let p = snd $1 <+> snd $4 in (FunctionTypeSpec (fst $4) [] Nothing p, p)}
  / '(' CommaDelimitedTypes ',' identifier "..." ')' "->" TypeSpec {let p = snd $1 <+> snd $7 in (FunctionTypeSpec (fst $8) (reverse $2) (Just $ extract_identifier $4) p, p)}
  / '(' CommaDelimitedTypes ')' "->" TypeSpec {let p = snd $1 <+> snd $5 in (FunctionTypeSpec (fst $5) (reverse $2) Nothing p, p)}

CommaDelimitedTypes
  <- TypeSpec {[fst $1]}
  / CommaDelimitedTypes ',' TypeSpec {fst $3 : $1}

OptionalBody
  <- ';' {(Nothing, NoPos)}
  / using UsingClauses ExprBlock {(Just $ pe (snd $1 <+> snd $2) $ Using (fst $2) $3, pos $3)}
  / ExprBlock {(Just $1, pos $1)}

OptionalRuleBody
  <- ';' {Nothing}
  / "=>" StandaloneExpr {Just $2}

TypeParams
  <- {([], NoPos)}
  / '[' TypeParams_ ']' {(reverse $2, snd $1 <+> snd $3)}

TypeParams_
  <- TypeParam {[$1]}
  / TypeParams_ ',' TypeParam {$3 : $1}

TypeParam
  <- TypeParam '=' TypeSpec {$1 {typeParamDefault = Just $ fst $3}}
  / upper_identifier TypeConstraints {(makeTypeParam (extract_upper_identifier $1)) {constraints = $2, typeParamIsConstant = False, typeParamPos = snd $1}}
  / macro_identifier {(makeTypeParam (extract_macro_identifier $1)) {constraints = [], typeParamIsConstant = True, typeParamPos = snd $1}}

TypeSpecParams
  <- {([], NoPos)}
  / '[' TypeSpecParams_ ']' {(reverse $2, snd $1 <+> snd $3)}

TypeSpecParams_
  <- TypeSpec {[fst $1]}
  / TypeSpecParams_ ',' TypeSpec {(fst $3) : $1}

TypeConstraints
  <- {[]}
  / ':' TypeSpec {[fst $2]}
  / "::" TypeConstraints_ {reverse $2}

TypeConstraints_
  <- TypeSpec {[fst $1]}
  / TypeConstraints_ '|' TypeSpec {fst $3 : $1}

UpperOrLowerIdentifier
  <- identifier {(extract_identifier $1, snd $1)}
  / upper_identifier {(extract_upper_identifier $1, snd $1)}

TypePath
  <- TypePath '.' UpperOrLowerIdentifier {(subPath (fst $1) (fst $3), snd $1 <+> snd $3)}
  / UpperOrLowerIdentifier {(([], fst $1), snd $1)}

ConstOrVar
  <- var { (False, snd $1) }
  / const { (True, snd $1) }

VarDefinition
  <- MetaMods ConstOrVar UpperOrLowerIdentifier TypeAnnotation OptionalDefault ';' {
    newVarDefinition {
      varName = ns $ fst $ $3,
      varMeta = reverse (metas $1),
      varType = fst $4,
      varModifiers = reverse (mods $1),
      varDefault = $5,
      varPos = snd $2 <+> snd $3,
      varIsConst = fst $2
    }
  }

VarDefinitions
  <- {[]}
  / VarDefinitions VarDefinition {$2 : $1}

VarBlock
  <- MetaMods '{' VarDefinitions '}' {
    [v {varMeta = varMeta v ++ metas $1, varModifiers = varModifiers v ++ mods $1} | v <- $3]
  }

OptionalStandaloneDefault
  <- ';' {(Nothing, snd $1)}
  / '=' undefined ';' {(Just $ pe (snd $1) Undefined, snd $1)}
  / '=' StandaloneExpr {(Just $2, snd $1 <+> pos $2)}

OptionalDefault
  <- {Nothing}
  / '=' undefined {Just $ pe (snd $1) Undefined}
  / '=' Expr {Just $2}

EnumVariant
  <- MetaMods upper_identifier ';' {
      newEnumVariant {
        variantName = ([], extract_upper_identifier $2),
        variantMeta = reverse $ metas $1,
        variantModifiers = reverse $ mods $1,
        variantArgs = [],
        variantValue = Nothing,
        variantPos = snd $2
      }
    }
  # | MetaMods upper_identifier '=' Expr ';' {
  #     newEnumVariant {
  #       variantName = ([], extract_upper_identifier $2),
  #       variantMeta = reverse $ metas $1,
  #       variantModifiers = reverse $ mods $1,
  #       variantArgs = [],
  #       variantValue = Just $4,
  #       variantPos = snd $2
  #     }
  #   }
  / MetaMods upper_identifier '(' Args ')' ';' {
      newEnumVariant {
        variantName = ([], extract_upper_identifier $2),
        variantMeta = reverse $ metas $1,
        variantModifiers = reverse $ mods $1,
        variantArgs = reverse $4,
        variantValue = Nothing,
        variantPos = snd $2
      }
    }

VarArgs
  <- Args ',' identifier "..." {($1, Just $ extract_identifier $3)}
  / Args {($1, Nothing)}

Args
  <- {[]}
  / ArgSpec {[$1]}
  / Args ',' ArgSpec {$3 : $1}

ArgSpec
  <- identifier TypeAnnotation OptionalDefault {ArgSpec {
    argName = extract_identifier $1,
     argType = fst $2,
     argDefault = $3,
     argPos = snd $1 <+> snd $2 <+> (case $3 of { Just x -> pos x; Nothing -> NoPos })
    }
  }

DefinitionBody
  <- ';' {Nothing}
  / '{' DefStatements '}' {Just (\x -> ps (snd $1 <+> snd $3) $ ExtendDefinition x $ reverse $2)}

DefStatements
  <- {[]}
  / DefStatements RewriteRule {(DefRule $2) : $1}
  / DefStatements RuleBlock {(map DefRule $2) ++ $1}
  / DefStatements FunctionDefinition {(DefMethod $2) : $1}
  / DefStatements VarDefinition {(DefField $2) : $1}
  / DefStatements VarBlock {(map DefField $2) ++ $1}
  / DefStatements EnumVariant {(DefVariant $2) : $1}

RewriteExpr
  <- Expr {$1}
  / StandaloneExpr {$1}

RewriteRule
  <- rule '(' RewriteExpr ')' OptionalRuleBody {
    newRewriteRule {
      rulePattern = $3,
      ruleBody = $5,
      rulePos = snd $1 <+> snd $4
    }
  }

RuleBlock
  <- rules '{' ShortRules '}' {$3}

ShortRules
  <- {[]}
  / ShortRules ShortRule {$2 : $1}

ShortRule
  <- '(' RewriteExpr ')' OptionalRuleBody {
    newRewriteRule {
      rulePattern = $2,
      ruleBody = $4,
      rulePos = snd $1 <+> snd $3
    }
  }

Expr <- RangeLiteral {$1}

RangeLiteral
  <- BinopTermAssign "..." BinopTermAssign {pe (pos $1 <+> pos $3) $ RangeLiteral $1 $3}
  / BinopTermAssign {$1}

BinopTermAssign
  <- ArrayAccessCallFieldExpr '=' BinopTermAssign {
    case expr $1 of
      ArrayAccess x y -> pe (pos $1 <+> pos $3) $ ArrayWrite x y $3
      Field x s -> pe (pos $1 <+> pos $3) $ FieldWrite x s $3
      _ -> pe (pos $1 <+> pos $3) $ Binop Assign $1 $3
  }
  / BinopTermCons {$1}
  / BinopTermCons '=' BinopTermAssign {pe (pos $1 <+> pos $3) $ Binop Assign $1 $3}
  / BinopTermCons assign_op BinopTermAssign {pe (pos $1 <+> pos $3) $ Binop (AssignOp (extract_assign_op $2)) $1 $3}
BinopTermCons
  <- BinopTermTernary {$1}
  / BinopTermTernary "::" BinopTermCons {pe (pos $1 <+> pos $3) $ Binop Cons $1 $3}
# TokenExpr
#  <-   : token LexMacroTokenAny {pe (snd $1 <+> snd $2) $ TokenExpr $ tc [$2]}
#  / BinopTermTernary {$1}
BinopTermTernary
  <- if BinopTermTernary then BinopTermTernary else BinopTermTernary {pe (snd $1 <+> pos $6) $ If $2 $4 (Just $6)}
  / BinopTermOr {$1}
BinopTermOr
  <- BinopTermAnd {$1}
  / BinopTermOr "||" BinopTermAnd {pe (pos $1 <+> pos $3) $ Binop Or $1 $3}
BinopTermAnd
  <- BinopTermEq {$1}
  / BinopTermAnd "&&" BinopTermEq {pe (pos $1 <+> pos $3) $ Binop And $1 $3}
BinopTermEq
  <- BinopTermCompare {$1}
  / BinopTermEq "==" BinopTermCompare {pe (pos $1 <+> pos $3) $ Binop Eq $1 $3}
  / BinopTermEq "!=" BinopTermCompare {pe (pos $1 <+> pos $3) $ Binop Neq $1 $3}
BinopTermCompare
  <- BinopTermBitOr {$1}
  / BinopTermCompare '>' BinopTermBitOr {pe (pos $1 <+> pos $3) $ Binop Gt $1 $3}
  / BinopTermCompare '<' BinopTermBitOr {pe (pos $1 <+> pos $3) $ Binop Lt $1 $3}
  / BinopTermCompare ">=" BinopTermBitOr {pe (pos $1 <+> pos $3) $ Binop Gte $1 $3}
  / BinopTermCompare "<=" BinopTermBitOr {pe (pos $1 <+> pos $3) $ Binop Lte $1 $3}
BinopTermBitOr
  <- BinopTermBitXor {$1}
  / BinopTermBitOr '|' BinopTermBitXor {pe (pos $1 <+> pos $3) $ Binop BitOr $1 $3}
BinopTermBitXor
  <- BinopTermBitAnd {$1}
  / BinopTermBitXor '^' BinopTermBitAnd {pe (pos $1 <+> pos $3) $ Binop BitXor $1 $3}
BinopTermBitAnd
  <- BinopTermShift {$1}
  / BinopTermBitAnd '&' BinopTermShift {pe (pos $1 <+> pos $3) $ Binop BitAnd $1 $3}
BinopTermShift
  <- BinopTermAdd {$1}
  / BinopTermShift "<<" BinopTermAdd {pe (pos $1 <+> pos $3) $ Binop LeftShift $1 $3}
  / BinopTermShift ">>" BinopTermAdd {pe (pos $1 <+> pos $3) $ Binop RightShift $1 $3}
BinopTermAdd
  <- BinopTermMul {$1}
  / BinopTermAdd '+' BinopTermMul {pe (pos $1 <+> pos $3) $ Binop Add $1 $3}
  / BinopTermAdd '-' BinopTermMul {pe (pos $1 <+> pos $3) $ Binop Sub $1 $3}
BinopTermMul
  <- BinopTermCustom {$1}
  / BinopTermMul '*' BinopTermCustom {pe (pos $1 <+> pos $3) $ Binop Mul $1 $3}
  / BinopTermMul '/' BinopTermCustom {pe (pos $1 <+> pos $3) $ Binop Div $1 $3}
  / BinopTermMul '%' BinopTermCustom {pe (pos $1 <+> pos $3) $ Binop Mod $1 $3}
BinopTermCustom
  <- CastExpr {$1}
  / BinopTermCustom custom_op CastExpr {pe (pos $1 <+> pos $3) $ Binop (Custom $ extract_custom_op $2) $1 $3}

CastExpr
  <- CastExpr as TypeSpec {pe (pos $1 <+> snd $3) $ Cast $1 (fst $3)}
  / Unop {$1}

Unop
  <- "++" VecExpr {pe (snd $1 <+> pos $2) $ PreUnop Inc $2}
  / "--" VecExpr {pe (snd $1 <+> pos $2) $ PreUnop Dec $2}
  / '!' VecExpr {pe (snd $1 <+> pos $2) $ PreUnop Invert $2}
  / '-' VecExpr {pe (snd $1 <+> pos $2) $ PreUnop Sub $2}
  / '~' VecExpr {pe (snd $1 <+> pos $2) $ PreUnop InvertBits $2}
  / '&' VecExpr {pe (snd $1 <+> pos $2) $ PreUnop Ref $2}
  / '*' VecExpr {pe (snd $1 <+> pos $2) $ PreUnop Deref $2}
  / VecExpr "++" {pe (pos $1 <+> snd $2) $ PostUnop Inc $1}
  / VecExpr "--" {pe (pos $1 <+> snd $2) $ PostUnop Dec $1}
  / VecExpr {$1}

VecExpr
  <- '[' ArrayElems ']' {pe (snd $1 <+> snd $3) $ ArrayLiteral $ reverse $2}
  / '[' ArrayElems ',' ']' {pe (snd $1 <+> snd $4) $ ArrayLiteral $ reverse $2}
  / '[' ']' { pe (snd $1 <+> snd $2) $ ArrayLiteral []}
  / ArrayAccessCallFieldExpr {$1}

ArrayElems
  <- Expr {[$1]}
  / ArrayElems ',' Expr {$3 : $1}

ArrayAccessCallFieldExpr
  <- ArrayAccessCallFieldExpr '[' ArrayElems ']' {foldr (\x acc -> pe (pos $1 <+> snd $4) $ ArrayAccess acc x) $1 $3}
  / ArrayAccessCallFieldExpr '(' CallArgs ')' {pe (pos $1 <+> snd $4) $ Call $1 [] (reverse $3)}
  / ArrayAccessCallFieldExpr '.' Identifier {pe (pos $1 <+> snd $3) $ Field $1 $ fst $3}
  / TypeAnnotatedExpr {$1}

TypeAnnotatedExpr
  <- TypeAnnotatedExpr ':' TypeSpec {pe (pos $1 <+> snd $3) $ TypeAnnotation $1 (fst $3)}
  / BaseExpr {$1}

BaseExpr
  <- Term {pe (snd $1) (Literal (fst $ fst $1) (snd $ fst $1))}
  / this {pe (snd $1) This}
  / Self {pe (snd $1) Self}
  / Identifier {pe (snd $1) $ Identifier (fst $1)}
  / '(' identifier "..." ')' {pe (snd $1 <+> snd $4) $ VarArgListCopy $ extract_identifier $2}
  / unsafe Expr {pe (snd $1 <+> pos $2) (Unsafe $2)}
  / sizeof TypeSpec {pe (snd $1 <+> snd $2) (SizeOf $ fst $2)}
  / sizeof '(' TypeSpec ')' {pe (snd $1 <+> snd $3) (SizeOf $ fst $3)}
  / defined Identifier {pe (snd $1 <+> snd $2) (Defined $ fst $2)}
  / defined '(' Identifier ')' {pe (snd $1 <+> snd $3) (Defined $ fst $3)}
  / '(' Expr ParenthesizedExprs ')' {if null $3 then $2 {pos = snd $1 <+> snd $4} else pe (snd $1 <+> snd $4) (TupleInit ($2 : reverse $3)) }
  / null {pe (snd $1) Null}
  / empty {pe (snd $1) Empty}
  / struct TypeSpec '{' StructInitFields '}' {pe (snd $1 <+> snd $5) $ StructInit (fst $2) $4}
  / struct TypeSpec {pe (snd $1 <+> snd $2) $ StructInit (fst $2) []}
  / union TypeSpec '{' StructInitField '}' {pe (snd $1 <+> snd $2) $ UnionInit (fst $2) $4}
  / implicit TypeSpec {pe (snd $1 <+> snd $2) $ Implicit $ fst $2}
  / inline_c TypeAnnotation {pe (snd $1 <+> snd $2) $ InlineCExpr (extract_inline_c $1) (fst $2)}
  / static Expr {pe (snd $1 <+> pos $2) (StaticExpr $2)}

ParenthesizedExprs
  <- {[]}
  / ParenthesizedExprs ',' Expr {$3 : $1}

Term
  <- bool {((BoolValue $ extract_bool $ fst $1, ConcreteType $ TypeBool), snd $1)}
  / str {((StringValue $ extract_lit $ fst $1, makeTypeSpec "CString"), snd $1)}
  / int {let x = extract_int_lit $ fst $1 in ((IntValue $ fst x, snd x), snd $1)}
  / float {let x = extract_float_lit $ fst $1 in ((FloatValue $ fst x, snd x), snd $1)}
  / char {((IntValue $ extract_char_lit $ fst $1, ConcreteType $ TypeChar), snd $1)}

StructInitFields
  <- {[]}
  / OneOrMoreStructInitFields ',' {reverse $1}
  / OneOrMoreStructInitFields {reverse $1}

OneOrMoreStructInitFields
  <- StructInitField {[$1]}
  / OneOrMoreStructInitFields ',' StructInitField {$3 : $1}

StructInitField
  <- UpperOrLowerIdentifier ':' Expr {(fst $1, $3)}
  / UpperOrLowerIdentifier {(fst $1, pe (snd $1) $ Identifier (Var $ ([], fst $1)))}

Identifier
  <- UpperOrLowerIdentifier {(Var $ ([], fst $1), snd $1)}
  / MacroIdentifier {$1}
  / '_' {(Hole, snd $1)}

MacroIdentifier
  <- macro_identifier {(MacroVar (extract_macro_identifier $1) (InferredType $ snd $1), snd $1)}
  / '$' '{' UpperOrLowerIdentifier TypeAnnotation '}' {(MacroVar (fst $3) (fst $4), (snd $1 <+> snd $5))}
  / '$' '{' '_' TypeAnnotation '}' {(MacroVar "_" (fst $4), (snd $1 <+> snd $5))}
